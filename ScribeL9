Recap :
1 Distributed Consencus: 
There are (n) nodes that each have an input value. Some of these nodes ​are faulty or malicious.The value must be generated by the honest node and honest node should be able to terminate the malicious nodes.All the nodes will have different sequences of transactions inside the network and each node input it's own proposed block and some transactions might be invalid because of the malicious nodes and a valid block will be selected as output out of these blocks.


Consencus protocol validity in bitcoin : As the network in bitcoin is imperfect and it's a peer to peer network not all pairs are connected to each other.And because of this all the nodes may not participate in the consencus protocol.This model doesn’t carry over very well to the Bitcoin setting because Bitcoin violates many of the assumptions built into the models.

Bitcoin consencus algorithm: A Distributed consencus protocol in bitcoin works as the broadcast a transaction message sent to all the nodes in the network that comprise the peer to peer network. A random node gets chance to write the ledger or into the block chain and it broadcasts its block and other nodes accept the block only if all the transactions in it are valid(verified signature).As to next continue the ledger, the node chooses the longest chain written.

Sybil attack​: Sybils are just copies of nodes that a malicious adversary can create to look like there are a lot of different participants, when in fact all those pseudo-participants are really controlled by the same adversary.

A malicious node can do fews things like stealing, denial of service and double spending.Double spending is possible but waiting for some block to join will avoid or reduce the possibility of double spending.


2.Incentives and proof of work :
Assuming that we’re able to pick a random node and, perhaps more problematically, that at least 50 percent of the time, this process will pick an honest node. This assumption of honesty is particularly problematic if there are financial incentives for participants to subvert the process, in which case we can’t really assume that a node will be honest. The question then becomes: can we give nodes an incentive for behaving honestly? We’re going to use bitcoins to incentivize the nodes that created the blocks that did end up on the long-term consensus chain.

The block reward​: According to the rules of Bitcoin, the node that creates a block gets to include a special transaction in that block. This transaction is a coin-creation transaction, and the node can also choose the recipient address of this transaction. Of course that node will typically choose an address belonging to itself. You can think of this as a payment to the node in exchange for the service of creating a block on the consensus chain. At the time of this writing, the value of the block reward is now fixed at 25 Bitcoins.The coin-creation transaction will only be accepted by other nodes if it ends up on the consensus chain.

The block reward is cut in half every four years limiting the total supply of bitcoins to 21 million. It is important to note that this is the only way in which new bitcoins are allowed to be created. There is no other coin generation mechanism, and that’s why 21 million is a final and total number (as the rules stand now, at least) for how many bitcoins there can ever be.


There are still a few problems remaining with the consensus mechanism as we described it. 
1.How we can pick a random node? 
2.The system can become unstable as the incentives cause a free-for-all where everybody wants to run a Bitcoin node in the hope of capturing some of these rewards. And 
3.An adversary might create a large number of Sybil nodes to try and subvert the consensus process.

All the above problems look like they are related to each other and all of them have the same solution which is called as the proof of work.

3.Proof of work: The key idea behind proof-of-work is that we approximate the selection of a random node by instead selecting nodes in proportion to a resource that we hope that nobody can monopolize, that resource is computing power. Another way of understanding this is that we’re allowing nodes to compete with each other by using their computing power, and that will result in nodes automatically being picked in that proportion. Yet another view of proof-of-work is that we’re making it moderately hard to create new identities. It’s sort of a tax on identity creation and therefore on the Sybil attack.

Bitcoin achieves the proof of work using hash puzzles, In order to create a block, the node that proposes that block is required to find a number, or nonce​, such that when you concatenate the nonce, the previous hash, and the list of transactions that comprise that block and take the hash of this whole string, then that hash output should be a number that falls into a target space that is quite small in relation to the much larger output space of that hash function. We can define such a target space as any value falling below a certain target value. In this case, the nonce will have to satisfy the following inequality: 
		H(nonce || prev_hash || tx || tx || … || tx) < target.


Parameterizable cost: we want the cost to be parameterizable, not a fixed cost for all time. The way that’s accomplished is that all the nodes in the Bitcoin peer-to-peer network will automatically recalculate the target, that is the size of the target space as a fraction of the output space, every (2016) blocks. They recalculate the target in such a way that the average time between successive blocks produced in the Bitcoin network is about 10 minutes. With a 10-minute average time between blocks the recalculation of the target happens roughly every two weeks.that means that each two week nodes will automatically readjust the target, and the amount of work that you have to do to be able to find a block is going to change. So if you put in a fixed amount of hardware investment, the rate at which you find blocks is actually dependent upon what other miners are doing. There’s a very nice formula to capture this, which is that the probability that any given miner, Alice, is going to win the next block is equivalent to the fraction of global hash power that she controls. This means that if Alice has mining hardware that’s about 0.1 percent of total hash power, she will find roughly one in every 1,000 blocks.

Lot of attacks on Bitcoin are infeasible if the majority of miners, weighted by hash power, are following the protocol — or, are honest. This is true because if a majority of miners, weighted by hash power, are honest, the competition for proposing the next block will automatically ensure that there is at least a 50 percent chance that the next block to be proposed at any point is coming from an honest node.


Putting it all together :
Cost of mining : At the current difficulty level, finding a single block takes computing about 10²⁰ hashes and the block reward is about 25 Bitcoins, which is a sizable amount of money at the current exchange rate.
If (block reward + tx fees) ​> (hardware cost + operating costs) then miner profits. 
the costs that the miner incurs are typically denominated in dollars or some other traditional currency, but their reward is denominated in bitcoin. So this equation has a hidden dependence on Bitcoin’s exchange rate at any given time.


Bootstrapping : There is a tricky interplay between three different ideas in Bitcoin: the security of the block chain, the health of the mining ecosystem, and the value of the currency.

We want the block chain to be secure for Bitcoin to be a viable currency. For the block chain to be secure, an adversary cannot create a lot of mining nodes and take over 50 percent or more of the new block creation.

How can we build a currency on top of such a ledger?
The first model you might think of is that you have an account-based system. You can add some transactions that create new coins and credit them to somebody. And then later you can transfer them. A transaction would say something like “we’re moving 17 coins from Alice to Bob”, and it will be signed by Alice.

[image]

The downside to this way of doing things is that anyone who wants to determine if a transaction is valid will have to keep track of these account balances. Does Alice have the 15 coins that she’s trying to transfer to David? To figure this out, you’d have to look backwards in time forever to see every transaction affecting Alice, and whether or not her net balance at the time that she tries to transfer 15 coins to David is greater than 15 coins.


Bitcoin doesn’t use an account-based model. Instead, Bitcoin uses a ledger that just keeps track of transactions. Transactions specify a number of inputs and a number of outputs. you can think of the inputs as coins being consumed and the outputs as coins being created. For transactions in which new currency is being minted, there are no coins being consumed . Each transaction has a unique identifier. Outputs are indexed beginning with 0, so we will refer to the first output as “output 0”.


Change addresses:

Why does Alice have to send money to herself in this example? in Bitcoin, the entirety of a transaction output must be consumed by another transaction, or none of it. Alice only wants to pay 17 bitcoins to Bob, but the output that she owns is worth 25 bitcoins. So she needs to create a new output where 8 bitcoins are sent back to herself. It could be a different address from the one that owned the 25 bitcoins, but it would have to be owned by her. This is called a change address​.

Efficient verification: 
When a new transaction is added to the ledger, how easy is it to check if it is valid? In this example, we need to look up the transaction output that Alice referenced, make sure that it has a value of 25 bitcoins, and that it hasn’t already been spent, We don’t need to go all the way back to the beginning of the block chain


Consolidating funds:
since transactions can have many inputs and many outputs, splitting and merging value is easy. For example, say Bob received money in two different transactions , I’d like to have one transaction I can spend later where I have all the bitcoins. That’s easy — he creates a transaction with the two inputs and one output, with the output address being one that he owns. That lets him consolidate those two transactions.

Joint payments:
Say Carol and Bob both want to pay David. They can create a transaction with two inputs and one output, but with the two inputs owned by two different people. And the only difference from the previous example is that since the two outputs from prior transactions that are being claimed here are from different addresses, the transaction will need two separate signatures — one by Carol and one by Bob.


Transaction syntax :

[image/transaction structure]

Metadata​: There’s some housekeeping information — the size of the transaction, the number of inputs, and the number of outputs. There’s the hash of the entire transaction which serves as a unique ID for the transaction

Inputs: ​The transaction inputs form an array, and each input has the same form. An input specifies a previous transaction, so it contains a hash of that transaction, which acts as a hash pointer to it. The input also contains the index of the previous transaction’s outputs that’s being claimed, And then there’s a signature.
Outputs: ​The outputs are an array. Each output has just two fields. They each have a value, and the sum of all the output values has to be less than or equal to the sum of all the input values. If the sum of the output values is less than the sum of the input values, the difference is a transaction fee to the miner who publishes this transaction.


